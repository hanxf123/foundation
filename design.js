/*
设计原则：
  1.单一职能原则(SRP)
  2.最少知识原则(LKP)
  3.开放-封闭原则(OCP)
*/
/*
1.单例模式
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点

使用场景：相对频繁、功能强大、创建一次相对消耗性能多

优点：唯一实例，节约内存开销；

缺点：1.违背单一职责原则，不好维护、不容易扩展
     2.不适用于容易变化的实例
*/
function A(name){
  // 如果已存在对应的实例，节约内存开销
  if(typeof A.instance === 'object'){
    return A.instance
  }
  //否则正常创建实例
  this.name = name

  // 缓存
  A.instance =this
  return this
}
var a1 = new A()
var a2= new A()
console.log(a1 === a2)//true
/*
2.代理模式
定义：代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问

使用场景：惰性加载，比如图片懒加载 缓存代理，比如http304、Memoization

优点：分解本体职责--单一职责原则；解决本体暂时性无法处理一些请求；节约性能

缺点：编码需要维护代理与本体的联系 编码需要保持代理和本体接口的一致性

种类：虚拟代理，缓存代理     es6提供Proxy构造函数能够让我们轻松的使用代理模式
*/
/*
3.策略模式
定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

使用场景：表单校验、算法分类、其他选择性较多且目标相同的需求

优点：1.避免多重条件选择语句
     2.遵循开发封闭原则，代码更易阅读、维护和扩展，一定程度上减少代码数量
     3.提高可复用性

缺点：违背最少知识原则，使用策略对象处耦合性大
*/
// if-else or switch
if (money === 100) {
  way = train()
} else if (money === 200) {
  way = car()
} else if (money === 300) {
  way = ship()
} else if (money === 400) {
  way = flight()
}
// 策略模式优化上面的代码
const wayMap = {
  m100: train(),
  m200: car(),
  m300: ship(),
  m400: flight()
}
/*
4.状态模式
定义：状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变

使用场景：状态机，把状态抽离出来单独封装在一个对象里面，直观方便，只需call(状态机)一下使用

优点：容易增加新状态或者切换当前状态 请求动作跟状态中封装的行为解耦 易维护扩展

缺点：逻辑分散不易读，状态多比较枯燥

理解：和策略模式差不多，但是策略模式是方法对外，让使用者根据状态去选择使用哪种策略；状态模式是内部逻辑，根据使用者的传参进行内部处理
*/

/*
策略模式和状态模式的区别
策略模式的客户端必须对所有的策略类相当了解，明确当前场景下各种策略的利弊，权衡在当前场景下应该使用哪种策略，也就是是说策略类对客户端是暴露的；
状态模式依赖于其状态的变化时其内部的行为发生变化，将动作委托到代表当前状态的对象，对外表现为类发生了变化。
*/

// if-else
if (age === 7) {
  work = primarySchool()
} else if (age === 13) {
  work = juniorMiddleSchool()
} else if (age === 16) {
  work = highSchool()
} else if (age === 19) {
  work = university()
} else if (age === 23) {
  work = growUP()
} else if (age > 24) {
  work = makeMoney()
}

// 状态模式
const workMap = {
  age7: primarySchool(),
  age13: juniorMiddleSchool(),
  age16: highSchool(),
  age19: university(),
  age23: growUP(),
  ageMore: makeMoney(),
}
/*
5.享元模式
定义：用于性能优化的模式，核心是运用共享技术来有效支持大量细粒度的对象

应用：大量被使用的对象

优点：解决大量对象带来的性能问题

缺点：利用时间换取空间的优化模式
*/
/*
6. 职责链模式模式
定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
*/
/*
7. 装饰者模式
定义：可以动态地给某个对象添加一些额外的职责装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责

理解：类似于propertype扩展
*/
/*
8. 发布-订阅模式模式
定义：定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式
发布者-（发布消息）->调度中心-（触发事件）->订阅者
                 订阅者-（订阅）->调度中心

理解：动了就去库里找，然后通知对应的地方修改
*/
/*
9.观察者模式
目标-（触发事件）->观察者
观察者-（订阅目标）->目标

理解：动了就改，像dom点击事件都属于观察者
*/
